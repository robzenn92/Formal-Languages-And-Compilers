\chapter{Exams done}

Formal Languages and Compilers - 2014, session 2\\
Exercise 1\\
Let

\begin{equation}
r_1 = (a(ab)^*b)^*(\varepsilon|a(ab)^*|abb)
\end{equation}
\begin{equation}
r_2 = (a(ab)^*b)^*
\end{equation}
\newline
Provide the minimum DFA that recognize the language $L(r_1) \setminus L(r_2)$, namely the set of words belonging to $L(r_1)$ but not to $L(r_2)$.

Exercise 2

Let $G$ be the following grammar:
$ S \rightarrow aA | bBc $ \\
$ A \rightarrow Bd | Cc $ \\
$ B \rightarrow e | \varepsilon $ \\
$ C \rightarrow f | \varepsilon $ \\
\newline
Say, justifying your answer, whether $G$ is LALR or not.

Exercise 3
\newline
Let $D$ be the following partially specified syntax-directed definition for statements:
\newline
Svolgimento:
\newline
We have to define the resulting language $L = L(r_1) \setminus L(r_2)$.

In order to do that we don't need to understan which words belongs to $L(r_1)$, which words belongs to $L(r_2)$ and then consider only the words that belongs to $L(r_1)$ but not to $L(r_2)$.
Both $r_1$ and $r_2$ has something in common: the first part of the regular expression such as $(a(ab)^*b)^*$.

Let this part $r_{common}$, then:
\begin{equation}
r_1 = r_{common}(\varepsilon|a(ab)^*|abb)
\end{equation}
This means that there are three possibilities to chooses:
\begin{enumerate}
\item The first is: $r_{common}\varepsilon$
\item The seconds is: $r_{common}a(ab)^*$
\item The third is: $r_{common}abb$
\end{enumerate}

Focus on the first and the third one, both could be generated by $L(r_2)$ so they cannot stay in the language $L = L(r_1) \setminus L(r_2)$.
\newline
The only way to recognize the set of words belonging to $L(r_1)$ but not to $L(r_2)$ is the follows:
\begin{equation}
L = L(r_{common}(a(ab)^*)) \rightarrow L = L((a(ab)^*b)^*(a(ab)^*))
\end{equation}
Now we want to find the minimum DFA that recognize L.
Try with an NFA..





















